<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- iPhone入力時の拡大防止 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>帯鋸演算</title>
  <!-- PWA meta -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#2563eb">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="帯鋸演算">
  <link rel="apple-touch-icon" href="icon-180.png">

  <style>
    :root{
      --bg:#111; --bg2:#0c0c0c; --panel:#181818; --panel2:#1f1f1f;
      --text:#fafafa; --muted:#c7c7c7; --border:#2b2b2b;
      --brand:#2f6dff; --brand2:#2455cc; --danger:#ff6b6b;
      --y:#ffd54f;          /* 機械設定・個数の黄色 */
      --radius:12px;
      --input-w:8ch;        /* 00000.0 が入る幅 */
      --label-w: 88px;      /* ラベル列幅 */
    }
    html,body{background:linear-gradient(180deg,var(--bg),var(--bg2) 60%); color:var(--text);}
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP",sans-serif;
      padding:16px; max-width:900px; margin:auto; -webkit-tap-highlight-color:transparent; -webkit-text-size-adjust:100%;
    }

    h1{margin:0 0 10px; font-size:20px; line-height:1.25; font-weight:700;}
    .unit-note{color:var(--muted); font-size:13px; margin:0 0 12px;}

    /* 設定 */
    .settings{
      background:var(--panel2); border:1px solid var(--border); border-radius:12px; padding:12px;
      display:grid; grid-template-columns: 1fr 1fr; gap:12px 16px;
    }
    .s-row{ display:grid; grid-template-columns: var(--label-w) auto; align-items:center; gap:6px 8px; }
    .s-span-2{ grid-column:1 / -1; display:grid; grid-template-columns: var(--label-w) auto; align-items:center; gap:6px 8px; }
    .s-label{ color:var(--muted); font-size:14px; }
    .unit{ color:var(--muted); margin-left:6px; font-size:13px; white-space:nowrap; line-height:1; }
    .s-row > div, .s-span-2 > div{ display:inline-flex; align-items:center; gap:6px; flex-wrap:nowrap; }
    input{
      width:var(--input-w); max-width:100%;
      padding:10px 12px; font-size:16px;
      border:1px solid var(--border); border-radius:var(--radius);
      background:#2a2a2a; color:var(--text); line-height:1.2;
      box-shadow:0 1px 0 rgba(255,255,255,.03) inset, 0 1px 8px rgba(0,0,0,.25);
    }
    input:focus{ outline:none; background:#343434; border-color:#3e3e3e; }

    /* 入力テーブル */
    h3{margin:16px 0 10px; font-size:16px;}
    .input-sheet{ background:var(--panel2); border:1px solid var(--border); border-radius:12px; padding:10px; }
    .sheet-head{ display:grid; grid-template-columns: 1fr 1fr; gap:8px 16px; padding:2px 2px 8px; color:var(--muted); font-size:13px; }
    #cutInputs{ display:grid; grid-template-columns: 1fr 1fr; gap:10px 16px; }
    .cut-input{ display:contents; }
    .cut-input .length, .cut-input .qty{ width:var(--input-w); }

    /* ボタン */
    .btn{
      background:var(--brand); color:#fff; border:none; border-radius:var(--radius);
      cursor:pointer; padding:12px 16px; font-size:16px; min-height:44px; line-height:1.2;
      box-shadow:0 2px 10px rgba(0,0,0,.35);
      white-space:nowrap;
    }
    .btn:hover{ background:var(--brand2); }
    .btn-calc{ background:#facc15; color:#111; }
    .btn-calc:hover{ background:#eab308; }
    .btn-reset{ background:#ef4444; }
    .btn-reset:hover{ background:#dc2626; }
    .btn-secret{ background:#8b5cf6; }
    .btn-secret:hover{ background:#7c3aed; }
    .btn-row{
      display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap:10px; margin-top:10px;
    }

    /* テストケース */
    .tests{
      margin-top:12px;
      display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap:10px; align-items:stretch;
    }
    .tests > span{ grid-column:1 / -1; color:var(--muted); margin:0 0 -2px; }
    .tests .btn{ white-space:normal; }

    /* 出力 */
    .result{ margin-top:14px; padding:16px; background:var(--panel2); border:1px solid var(--border); border-radius:14px; font-size:15px; line-height:1.65; letter-spacing:.2px; white-space:normal; }
    .y{ color:var(--y); font-weight:600; }
    .danger{ color:#ff6b6b; font-weight:700; }

    .table-wrap{ margin-top:12px; background:var(--panel2); border:1px solid var(--border); border-radius:12px; overflow:auto; }
    .table{ width:100%; min-width:760px; border-collapse:separate; border-spacing:0; font-size:15px; line-height:1.5; }
    .table th, .table td{ padding:10px 12px; border-bottom:1px solid var(--border); white-space:nowrap; }
    .table thead th{ position:sticky; top:0; background:var(--panel2); z-index:1; text-align:left; color:var(--muted); font-weight:600; backdrop-filter:blur(4px); }
    .num{ text-align:right; font-variant-numeric:tabular-nums; }
    .group-head{ font-weight:600; }
    .table tr:last-child td{ border-bottom:none; }
    .subtle{ color:var(--muted); }

    @media (max-width:560px){
      .settings{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>帯鋸演算</h1>
  <div class="unit-note">（長さ単位：mm）</div>

  <!-- 設定 -->
  <div class="settings">
    <div class="s-row">
      <label class="s-label" for="stockLength">部材長</label>
      <div><input type="number" id="stockLength" value="1000"><span class="unit">mm</span></div>
    </div>
    <div class="s-row">
      <label class="s-label" for="stockCount">個数</label>
      <div><input type="number" id="stockCount" value="10"><span class="unit">本</span></div>
    </div>
    <div class="s-row">
      <label class="s-label" for="grip">掴みしろ</label>
      <div><input type="number" id="grip" value="129"><span class="unit">mm</span></div>
    </div>
    <div class="s-row">
      <label class="s-label" for="tolerance">切断誤差</label>
      <div><input type="number" id="tolerance" value="1"><span class="unit">mm</span></div>
    </div>
    <div class="s-span-2">
      <label class="s-label" for="kerf">1カットの削れ</label>
      <div><input type="number" id="kerf" value="2.5"><span class="unit">mm</span></div>
    </div>
    <!-- 余り(目標)：裏モードのみ使用 -->
    <div class="s-span-2">
      <label class="s-label" for="wasteTarget">余り(目標)</label>
      <div><input type="number" id="wasteTarget" placeholder="例:160"><span class="unit">mm</span></div>
    </div>
  </div>

  <!-- 切断長さと本数 -->
  <h3>切断長と個数（MAX30）</h3>
  <div class="input-sheet">
    <div class="sheet-head"><div>長さ</div><div>個数</div></div>
    <div id="cutInputs"></div>
  </div>

  <!-- 操作ボタン -->
  <div class="btn-row">
    <button class="btn" onclick="addCutInput()">切断パターン追加</button>
    <button class="btn btn-calc" onclick="run()">演算</button>
    <button class="btn btn-reset" onclick="resetCuts()">リセット</button>
    <button class="btn btn-secret" onclick="run(true)">裏モード</button>
  </div>

  <!-- テストケース -->
  <div class="tests">
    <span>■ テストケース：</span>
    <button class="btn" onclick="loadTest(1)">T1: 400×2, 100×4 / 1000×3</button>
    <button class="btn" onclick="loadTest(2)">T2: 200×5（+1誤差）/ 1000×1</button>
    <button class="btn" onclick="loadTest(3)">T3: 600×1, 300×2 / 1000×2</button>
    <button class="btn" onclick="loadTest(4)">T4: 400×10, 100×30, 60×40 / 1000×10</button>
  </div>

  <div class="result" id="result"></div>

  <script>
    if (!window.__OBIKYO__) window.__OBIKYO__ = {};
    if (!window.__OBIKYO__.initialized) {
      window.__OBIKYO__.initialized = true;
      window.__OBIKYO__.cutRowCount = 0;

      /* 小数1桁丸め */
      const r1 = (v)=> Math.round(v*10)/10;

      /* 行追加（最大30） */
      window.addCutInput = function(length="", qty=""){
        const maxRows=30;
        if(window.__OBIKYO__.cutRowCount>=maxRows) return;
        const row=document.createElement('div');
        row.className='cut-input';
        row.innerHTML = `
          <input type="number" class="length" placeholder="長さ" aria-label="長さ(mm)" value="${length}">
          <input type="number" class="qty" placeholder="個数" aria-label="個数(本)" value="${qty}">
        `;
        document.getElementById('cutInputs').appendChild(row);
        window.__OBIKYO__.cutRowCount++;
      };

      function alertError(msg){ try{ alert(msg);}catch(e){} if(navigator.vibrate){navigator.vibrate(240);} }

      /* 入力→切断リスト展開 */
      function buildCuts(tolerance){
        const lengths=[...document.querySelectorAll('.length')];
        const qtys=[...document.querySelectorAll('.qty')];
        const cuts=[];
        for(let i=0;i<lengths.length;i++){
          const target=Number(lengths[i].value);
          const qty=Number(qtys[i].value);
          if(!target || !qty) continue;
          const input=r1(target-Number(tolerance));
          for(let j=0;j<qty;j++) cuts.push({target:r1(target), input});
        }
        return cuts;
      }

      function statsFromCuts(cuts,kerf){
        const map=new Map(); let totalCuts=0,totalUsage=0;
        for(const c of cuts){ map.set(c.target,(map.get(c.target)||0)+1); totalCuts++; totalUsage+=r1(c.target+kerf); }
        return {countByTarget:map,totalCuts,totalUsage};
      }

      /* 初期割当（長い順） */
      function assignBoardsDescending(cuts,stockLength,stockCount,grip,kerf){
        const boards=Array.from({length:stockCount},(_,i)=>({id:i+1,cuts:[],used:0}));
        let remaining=cuts.slice().sort((a,b)=>b.target-a.target);
        const CANDIDATE_LIMIT=60, NODE_LIMIT=20000;

        for(const board of boards){
          if(remaining.length===0) break;
          const capacity=r1(stockLength-grip);
          const pool=remaining.slice(0,Math.min(CANDIDATE_LIMIT,remaining.length));
          let bestPlan=[],bestUsed=0,nodes=0;

          (function dfs(idx,used,chosen){
            if(++nodes>NODE_LIMIT) return;
            if(used>bestUsed){bestUsed=used;bestPlan=chosen.slice();}
            for(let i=idx;i<pool.length;i++){
              const c=pool[i], need=r1(c.target+kerf);
              if(used+need>capacity) continue;
              chosen.push(c); dfs(i+1,r1(used+need),chosen); chosen.pop();
            }
          })(0,0,[]);

          board.cuts=bestPlan;
          board.used=bestPlan.reduce((s,c)=>r1(s+c.target+kerf),0);
          const set=new Set(bestPlan);
          remaining=remaining.filter(x=>!set.has(x));
        }
        return {boards,remaining};
      }

      /* ギャップ埋め（短い順） */
      function gapFill(boards,remaining,stockLength,grip,kerf){
        remaining.sort((a,b)=>a.target-b.target);
        for(const board of boards){
          let cap=r1((stockLength-grip)-board.used); if(cap<=0) continue;
          for(let i=0;i<remaining.length && cap>0;){
            const c=remaining[i], need=r1(c.target+kerf);
            if(need<=cap+1e-9){ board.cuts.push(c); board.used=r1(board.used+need); cap=r1(cap-need); remaining.splice(i,1);}
            else break;
          }
          const capMax=r1(stockLength-grip); if(board.used>capMax) board.used=capMax;
        }
        return remaining;
      }

      function tallyCuts(cuts){
        const map=new Map();
        for(const c of cuts){
          const key=`${c.input}->${c.target}`;
          if(!map.has(key)) map.set(key,{input:c.input,target:c.target,count:0});
          map.get(key).count++;
        }
        return Array.from(map.values()).sort((a,b)=>a.target-b.target||a.input-b.input);
      }
      function compressIds(ids){
        ids.sort((a,b)=>a-b); const ranges=[]; let s=ids[0],p=ids[0];
        for(let i=1;i<ids.length;i++){ const c=ids[i]; if(c===p+1){p=c;continue;} ranges.push(s===p?`${s}`:`${s}〜${p}`); s=p=c; }
        ranges.push(s===p?`${s}`:`${s}〜${p}`); return ranges.join(',');
      }

      /* 出力レンダリング */
      function renderOutput(boards,shortageMap,stockLength,grip,audit){
        const SL=Number(stockLength), GR=Number(grip);
        const sigMap=new Map();
        for(const b of boards){
          if(!b?.cuts?.length) continue;
          const tally=tallyCuts(b.cuts);
          const rEx=Math.max(0, r1((SL-GR)-b.used));
          const rIn=Math.max(0, r1(SL-b.used));
          const sig=JSON.stringify({tally,rEx:+rEx.toFixed(3),rIn:+rIn.toFixed(3)});
          if(!sigMap.has(sig)) sigMap.set(sig,{ids:[],tally,rEx,rIn});
          sigMap.get(sig).ids.push(b.id);
        }

        let totalRemain=0, rowsHtml='';
        for(const {ids,tally,rEx,rIn} of Array.from(sigMap.values()).sort((a,b)=>a.ids[0]-b.ids[0])){
          totalRemain += rIn * ids.length;
          const group=`部材${compressIds(ids)}`;
          const remainCell=`<td class="num" rowspan="${tally.length}">${rIn.toFixed(1)}</td><td class="num" rowspan="${tally.length}">${rEx.toFixed(1)}</td>`;
          tally.forEach((row,i)=>{
            const inp=Number(row.input).toFixed(1);
            const tgt=Number(row.target).toFixed(1);
            const qty=row.count;
            const usedLen=(Number(row.target)*qty).toFixed(1);
            const kerfSum=(qty*Number(document.getElementById('kerf').value)).toFixed(1);
            rowsHtml += `<tr>
              ${i===0?`<td class="group-head" rowspan="${tally.length}">${group}</td>`:``}
              <td class="num">${tgt}</td>
              <td class="num y">${inp}</td>
              <td class="num y">${qty}</td>
              ${i===0?remainCell:``}
              <td class="num">${usedLen}</td>
              <td class="num subtle">${kerfSum}</td>
            </tr>`;
          });
        }

        const tableHtml = `
          <div class="table-wrap">
            <table class="table">
              <thead>
                <tr>
                  <th>部材</th><th class="num">実長</th><th class="num">機械設定</th><th class="num">本数</th>
                  <th class="num">余り</th><th class="num">有効残長</th><th class="num">実使用長</th><th class="num">削れ合計</th>
                </tr>
              </thead>
              <tbody>${rowsHtml || `<tr><td colspan="8" class="subtle">切断結果がありません</td></tr>`}</tbody>
            </table>
          </div>`;

        const keys=Array.from(shortageMap.keys()).sort((a,b)=>a-b);
        let below = `<div style="margin-top:8px">合計余り（掴みしろ含む・全材）：<b>${totalRemain.toFixed(1)} mm</b></div>`;
        if(keys.length>0){
          below += `<div style="margin-top:6px"><b class="danger">切断不足：</b>` +
                   keys.map(k=>` <span class="danger">${Number(k).toFixed(1)}mm × ${shortageMap.get(k)}本</span>`).join(' / ') + `</div>`;
          alertError('切断不足があります。入力や条件をご確認ください。');
        }else{
          below += `<div style="margin-top:6px"><b>切断不足：</b>なし</div>`;
        }
        below += `<div style="margin-top:8px" class="subtle">
          --- 監査 ---　要求 ${audit.demandUsage.toFixed(1)}mm ／ 容量 ${audit.totalCapacity.toFixed(1)}mm ／ 実割当 ${audit.assignedUsage.toFixed(1)}mm ／ 不足発生 ${audit.demandUsage>audit.totalCapacity?'はい':'いいえ'}
        </div>`;
        document.getElementById('result').innerHTML = tableHtml + below;
      }

      /* 共通実行関数
         secret=true のとき裏モード（捨て切り自動追加） */
      window.run = function(secret=false){
        const stockLength=Number(document.getElementById('stockLength').value);
        const stockCount=Number(document.getElementById('stockCount').value);
        const grip=Number(document.getElementById('grip').value);
        const kerf=Number(document.getElementById('kerf').value);
        const tolerance=Number(document.getElementById('tolerance').value);
        const wasteTarget=Number(document.getElementById('wasteTarget').value);
        document.getElementById('result').textContent='';

        const cuts=buildCuts(tolerance);
        if(cuts.length===0 || stockCount<=0 || stockLength<=0){
          document.getElementById('result').textContent='入力が不足しています。'; return;
        }
        const demand=statsFromCuts(cuts,kerf);
        const totalCapacity=r1((stockLength-grip)*stockCount);

        let {boards,remaining}=assignBoardsDescending(cuts,stockLength,stockCount,grip,kerf);
        remaining = gapFill(boards,remaining,stockLength,grip,kerf);

        /* --- 裏モード：各部材ごとに余り(目標)へ合わせる捨て切りを自動追加 --- */
        if(secret){
          if(!(wasteTarget>0)){ alertError('裏モード：余り(目標)を入力してください。'); }
          else if(wasteTarget <= grip){ alertError('裏モード：余り(目標)は掴みしろより大きい値にしてください。'); }
          else{
            const MIN_EFFECTIVE = 50; // 指定：有効残が50mm以上のときのみ捨て切り
            for(const b of boards){
              const usedNow = b.used;
              const rIn = r1(stockLength - usedNow);           // 掴みしろ含む残長
              const rEx = r1((stockLength - grip) - usedNow);  // 有効残長

              const diff = r1(rIn - wasteTarget);              // 余りを目標にするための差
              if(rEx >= MIN_EFFECTIVE && diff > kerf + 1e-9){
                const dropActual = r1(diff - kerf);            // 実長 (= 差分 − 削れ)
                if(dropActual > 0){
                  const dropInput  = r1(dropActual - tolerance); // 機械設定
                  // 1本だけ捨て切りを追加
                  b.cuts.push({target: dropActual, input: dropInput});
                  b.used = r1(b.used + dropActual + kerf);
                }
              }
            }
          }
        }

        // 再集計（不足など）
        const assignedCutsArray=boards.flatMap(b=>b.cuts);
        const assigned=statsFromCuts(assignedCutsArray,kerf);

        const shortageMap=new Map();
        for(const c of remaining) shortageMap.set(c.target,(shortageMap.get(c.target)||0)+1);
        if(shortageMap.size===0){
          for(const [t,need] of demand.countByTarget.entries()){
            const done=assigned.countByTarget.get(t)||0;
            if(done<need) shortageMap.set(t,need-done);
          }
        }

        const audit={ demandUsage:demand.totalUsage, totalCapacity, assignedUsage:assigned.totalUsage };
        renderOutput(boards,shortageMap,stockLength,grip,audit);
      };

      /* 旧API互換（演算ボタン） */
      window.calculate = ()=> run(false);

      /* リセット */
      window.resetCuts = function(){
        document.getElementById('cutInputs').innerHTML='';
        window.__OBIKYO__.cutRowCount=0;
        document.getElementById('result').textContent='';
      };

      /* テストケース */
      window.loadTest = function(id){
        resetCuts();
        const L=(v)=>document.getElementById(v);
        if(id===1){ L('stockLength').value=1000; L('stockCount').value=3; L('grip').value=129; L('kerf').value=2.5; L('tolerance').value=1; addCutInput(400,2); addCutInput(100,4); }
        else if(id===2){ L('stockLength').value=1000; L('stockCount').value=1; L('grip').value=100; L('kerf').value=2.5; L('tolerance').value=1; addCutInput(200,5); }
        else if(id===3){ L('stockLength').value=1000; L('stockCount').value=2; L('grip').value=120; L('kerf').value=3; L('tolerance').value=0; addCutInput(600,1); addCutInput(300,2); }
        else if(id===4){ L('stockLength').value=1000; L('stockCount').value=10; L('grip').value=129; L('kerf').value=2.5; L('tolerance').value=1; addCutInput(400,10); addCutInput(100,30); addCutInput(60,40); }
        run(false);
      };
      /* 初期の空3行は作らない */
    }
  </script>

  <script>
    if('serviceWorker' in navigator){
      window.addEventListener('load',()=>{ navigator.serviceWorker.register('./sw.js').catch(console.error); });
    }
  </script>
</body>
</html>
