<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- iPhone入力時の拡大防止 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>帯鋸演算</title>
  <!-- PWA meta -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#2563eb">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="帯鋸演算">
  <link rel="apple-touch-icon" href="icon-180.png">
  <style>
 /* ===== iPhone視認性＆タップ性 改善 ===== */
:root{
  --bg:#111; --bg2:#0c0c0c; --panel:#181818; --panel2:#1f1f1f;
  --text:#fafafa; --muted:#c7c7c7; --border:#2e2e2e;
  --brand:#2f6dff; --brand2:#2455cc; --danger:#ff6b6b;
}

html,body{background:linear-gradient(180deg,var(--bg),var(--bg2) 60%); color:var(--text);}
body{
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP",sans-serif;
  padding:16px; max-width:900px; margin:auto; -webkit-tap-highlight-color:transparent;
  -webkit-text-size-adjust:100%;
}

/* 見出しを短く、余白はしっかり */
h1{margin:0 0 12px; font-size:20px; line-height:1.25; font-weight:700;}

/* ラベルは縦積み（スマホ時）で読みやすく、単位は薄め */
label{color:var(--muted); font-size:15px; display:flex; flex-direction:column; gap:6px;}
label > span{opacity:.85}

/* 入力欄はタップしやすく、角丸＆影を控えめに */
input{
  width:100%; max-width:180px; padding:12px 14px; font-size:16px;
  border:1px solid var(--border); border-radius:12px; background:var(--panel); color:var(--text);
  box-shadow:0 1px 0 rgba(255,255,255,.03) inset, 0 1px 8px rgba(0,0,0,.25);
}

/* 行配置：スマホでは縦積み、タブレット以上で横並び */
.row{display:flex; flex-wrap:wrap; gap:14px 18px; align-items:flex-end; margin-bottom:8px;}
@media (min-width:700px){
  .row label{flex-direction:row; align-items:center;}
  .row input{max-width:140px;}
}

/* 追加/演算ボタン：押しやすいサイズ＋2列グリッドで詰まらない */
.btn{
  background:var(--brand); color:#fff; border:none; border-radius:12px; cursor:pointer;
  padding:12px 16px; font-size:16px; min-height:44px; line-height:1.2;
  box-shadow:0 2px 10px rgba(0,0,0,.35);
}
.btn:hover{background:var(--brand2);}

/* テストボタンはカード化＆2列グリッド */
.tests{margin-top:12px; display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:10px;}
.tests > span{grid-column:1 / -1; color:var(--muted); margin-bottom:2px;}
.tests .btn{width:100%;}

/* 結果パネル：読みやすい文字サイズ＆行間、情報の強弱を付ける */
.result{
  margin-top:14px; padding:16px; background:var(--panel2); border:1px solid var(--border); border-radius:14px;
  white-space:pre-wrap; font-family: -apple-system, BlinkMacSystemFont, "Noto Sans JP", sans-serif; /* 等幅→可読性重視 */
  font-size:15px; line-height:1.6; letter-spacing:.2px;
}

/* 出力テキストの簡易ハイライト（先頭の【部材…】行を太字に） */
.result { counter-reset: grp; }
.result::selection{background:#2643a5; color:#fff;}
.result b{font-weight:700;}
.error{color:var(--danger); font-weight:700;}
/* 箇条書きの点を見やすく */
.result { --dot:'・'; }

  </style>
</head>
<body>
  <h1>帯鋸演算（HTML版・長尺優先+ギャップ埋め+監査）</h1>

  <div class="row">
    <label>部材長さ: <input type="number" id="stockLength" value="1000"> mm</label>
    <label>本数: <input type="number" id="stockCount" value="10"> 本</label>
    <label>掴みしろ: <input type="number" id="grip" value="129"> mm</label>
  </div>
  <div class="row">
    <label>切断誤差 (+mm): <input type="number" id="tolerance" value="1"></label>
    <label>1カットごとの削れ: <input type="number" id="kerf" value="2.5"> mm</label>
  </div>

  <h3>切断長さと本数（最大30種類）</h3>
  <div id="cutInputs"></div>
  <div class="row">
    <button class="btn" onclick="addCutInput()">切断パターン追加</button>
    <button class="btn" onclick="calculate()">演算</button>
  </div>

  <div class="tests">
    <span>■ テストケース：</span>
    <button class="btn" onclick="loadTest(1)">T1: 400×2, 100×4 / 1000×3</button>
    <button class="btn" onclick="loadTest(2)">T2: 200×5（+1誤差）/ 1000×1</button>
    <button class="btn" onclick="loadTest(3)">T3: 600×1, 300×2 / 1000×2</button>
    <button class="btn" onclick="loadTest(4)">T4: 400×10, 100×30, 60×40 / 1000×10</button>
  </div>

  <div class="result" id="result"></div>

  <audio id="beep" src="beep.mp3"></audio>

  <script>
    // --- ガード: 重複定義の回避（ホットリロード等対策） ---
    if (!window.__OBIKYO__) window.__OBIKYO__ = {};

    // 一度だけ定義
    if (!window.__OBIKYO__.initialized) {
      window.__OBIKYO__.initialized = true;
      window.__OBIKYO__.cutRowCount = 0;

      window.addCutInput = function addCutInput(length = "", qty = "") {
        const maxRows = 30;
        if (window.__OBIKYO__.cutRowCount >= maxRows) return;
        const div = document.createElement('div');
        div.className = 'cut-input row';
        div.innerHTML = `長さ: <input type="number" class="length" value="${length}"> × <input type="number" class="qty" value="${qty}"> 本`;
        document.getElementById('cutInputs').appendChild(div);
        window.__OBIKYO__.cutRowCount++;
      }

      function beep() {
        const a = document.getElementById('beep');
        if (a) { a.currentTime = 0; a.play().catch(()=>{}); }
      }

      function buildCuts(tolerance) {
        const lengths = [...document.querySelectorAll('.length')];
        const qtys = [...document.querySelectorAll('.qty')];
        const cuts = [];
        for (let i = 0; i < lengths.length; i++) {
          const target = Number(lengths[i].value);
          const qty = Number(qtys[i].value);
          if (!target || !qty) continue;
          const input = target - tolerance; // 誤差+1 → 設定を1短く
          for (let j = 0; j < qty; j++) cuts.push({ target, input });
        }
        return cuts;
      }

      function statsFromCuts(cuts, kerf) {
        const map = new Map();
        let totalCuts = 0, totalUsage = 0;
        for (const c of cuts) {
          map.set(c.target, (map.get(c.target) || 0) + 1);
          totalCuts += 1;
          totalUsage += (c.target + kerf);
        }
        return { countByTarget: map, totalCuts, totalUsage };
      }

      function assignBoardsDescending(cuts, stockLength, stockCount, grip, kerf) {
        // 第1パス：長い順で“初期割当”
        const boards = Array.from({length: stockCount}, (_, i) => ({ id: i+1, cuts: [], used: 0 }));
        // 長い順
        let remaining = cuts.slice().sort((a, b) => b.target - a.target);

        const CANDIDATE_LIMIT = 60;   // 1部材に対して評価する候補上限
        const NODE_LIMIT = 20000;     // DFSノード上限

        for (const board of boards) {
          if (remaining.length === 0) break;
          const capacity = stockLength - grip; // 有効長
          const pool = remaining.slice(0, Math.min(CANDIDATE_LIMIT, remaining.length));

        let bestPlan = [];
        let bestUsed = 0;
        let nodes = 0;

          function dfs(idx, used, chosen) {
            if (++nodes > NODE_LIMIT) return;
            if (used > bestUsed) { bestUsed = used; bestPlan = chosen.slice(); }
            for (let i = idx; i < pool.length; i++) {
              const c = pool[i];
              const need = c.target + kerf; // 本ごとの削れ加算
              if (used + need > capacity) continue;
              chosen.push(c);
              dfs(i + 1, used + need, chosen);
              chosen.pop();
            }
          }
          dfs(0, 0, []);

          board.cuts = bestPlan;
          board.used = bestPlan.reduce((s, c) => s + c.target + kerf, 0);
          const set = new Set(bestPlan);
          remaining = remaining.filter(x => !set.has(x));
        }
        return { boards, remaining };
      }

      function gapFill(boards, remaining, stockLength, grip, kerf) {
        // 第2パス：短い順でギャップ埋め
        remaining.sort((a, b) => a.target - b.target);
        for (const board of boards) {
          let cap = (stockLength - grip) - board.used; // 有効残長
          if (cap <= 0) continue;
          for (let i = 0; i < remaining.length && cap > 0; ) {
            const c = remaining[i];
            const need = c.target + kerf;
            if (need <= cap + 1e-9) { // 浮動小数誤差対策
              board.cuts.push(c);
              board.used += need;
              cap -= need;
              remaining.splice(i, 1);
            } else {
              // 最短が入らないならそれ以降も入らない
              break;
            }
          }
          // 念のためクランプ（誤差で越境しないよう）
          const capMax = stockLength - grip;
          if (board.used > capMax) board.used = capMax;
        }
        return remaining;
      }

      function tallyCuts(cuts) {
        const map = new Map();
        for (const c of cuts) {
          const key = `${c.input}->${c.target}`; // 機械設定→実長で同一視
          if (!map.has(key)) map.set(key, { input: c.input, target: c.target, count: 0 });
          map.get(key).count++;
        }
        return Array.from(map.values()).sort((a,b)=> a.target - b.target || a.input - b.input);
      }

      function compressIds(ids) {
        ids.sort((a,b)=>a-b);
        const ranges = [];
        let start = ids[0], prev = ids[0];
        for (let i = 1; i < ids.length; i++) {
          const cur = ids[i];
          if (cur === prev + 1) { prev = cur; continue; }
          ranges.push(start === prev ? `${start}` : `${start}〜${prev}`);
          start = prev = cur;
        }
        ranges.push(start === prev ? `${start}` : `${start}〜${prev}`);
        return ranges.join(',');
      }

      function renderOutput(boards, shortageMap, stockLength, grip, audit) {
        const SL = Number(stockLength), GR = Number(grip);

        // 1) ボードごとに集計＆シグネチャ化（まとめ表示）
        const sigMap = new Map();
        for (const board of boards) {
          if (!board || !Array.isArray(board.cuts) || board.cuts.length === 0) continue;
          const tally = tallyCuts(board.cuts);
          const rEx = Math.max(0, (SL - GR) - board.used);
          const rIn = Math.max(0, SL - board.used); // 掴みしろ含む残長
          const sig = JSON.stringify({ tally, rEx: +rEx.toFixed(3), rIn: +rIn.toFixed(3) });
          if (!sigMap.has(sig)) sigMap.set(sig, { ids: [], tally, rEx, rIn });
          sigMap.get(sig).ids.push(board.id);
        }

        let out = '';
        let totalRemainInclGrip = 0;
        for (const { ids, tally, rEx, rIn } of Array.from(sigMap.values()).sort((a,b)=>a.ids[0]-b.ids[0])) {
          totalRemainInclGrip += rIn * ids.length; // グループ数分
          out += `【部材${compressIds(ids)}】\n`;
          for (const row of tally) {
            out += `・${row.input}mm（機械設定） → ${row.target}mm（実長） × ${row.count}本\n`;
          }
          out += `余り（掴みしろ含む）: ${rIn.toFixed(1)} mm（内 有効残長: ${rEx.toFixed(1)} mm）\n\n`;
        }
        out += `合計余り（掴みしろ含む・全材）: ${totalRemainInclGrip.toFixed(1)} mm\n`;

        // 2) 不足
        const keys = Array.from(shortageMap.keys()).sort((a,b)=>a-b);
        if (keys.length > 0) {
          out += `\n切断不足：\n`;
          for (const k of keys) out += `・${k}mm × ${shortageMap.get(k)}本\n`;
          beep();
        } else {
          out += `\n切断不足：なし\n`;
        }

        // 3) 監査（総量チェック）
        out += `\n--- 監査 ---\n`;
        out += `要求合計（長さ+削れ）: ${audit.demandUsage.toFixed(1)} mm\n`;
        out += `理論容量（有効×本数）: ${audit.totalCapacity.toFixed(1)} mm\n`;
        out += `実割当（長さ+削れ）: ${audit.assignedUsage.toFixed(1)} mm\n`;
        out += `理論上 不足発生?: ${audit.demandUsage > audit.totalCapacity ? 'はい' : 'いいえ'}\n`;

        document.getElementById('result').textContent = out;
      }

      window.calculate = function calculate() {
        const stockLength = Number(document.getElementById('stockLength').value);
        const stockCount = Number(document.getElementById('stockCount').value);
        const grip = Number(document.getElementById('grip').value);
        const kerf = Number(document.getElementById('kerf').value);
        const tolerance = Number(document.getElementById('tolerance').value);
        document.getElementById('result').textContent = '';

        // 1) 切断データ展開
        const cuts = buildCuts(tolerance);
        if (cuts.length === 0 || stockCount <= 0 || stockLength <= 0) {
          document.getElementById('result').textContent = '入力が不足しています。';
          return;
        }
        const demand = statsFromCuts(cuts, kerf);
        const totalCapacity = (stockLength - grip) * stockCount;

        // 2) 長尺優先の初期割当
        const { boards, remaining } = assignBoardsDescending(cuts, stockLength, stockCount, grip, kerf);

        // 3) 短尺優先のギャップ埋め
        const afterGap = gapFill(boards, remaining, stockLength, grip, kerf);

        // 4) 実際に割り当てた本数・使用量を算出
        const assignedCutsArray = boards.flatMap(b => b.cuts);
        const assigned = statsFromCuts(assignedCutsArray, kerf);

        // 5) 不足の再計算（参照落ち等を完全排除）
        const shortageMap = new Map();
        // 5-1) まず残リストから加算
        for (const c of afterGap) shortageMap.set(c.target, (shortageMap.get(c.target) || 0) + 1);
        // 5-2) それでも不足0のとき、総量で差分チェック
        if (shortageMap.size === 0) {
          for (const [t, need] of demand.countByTarget.entries()) {
            const done = assigned.countByTarget.get(t) || 0;
            if (done < need) shortageMap.set(t, need - done);
          }
        }

        // 6) 監査データ
        const audit = {
          demandUsage: demand.totalUsage,
          totalCapacity: totalCapacity,
          assignedUsage: assigned.totalUsage
        };

        // 7) 出力
        renderOutput(boards, shortageMap, stockLength, grip, audit);
      }

      window.resetCuts = function resetCuts() {
        document.getElementById('cutInputs').innerHTML = '';
        window.__OBIKYO__.cutRowCount = 0;
      }

      window.loadTest = function loadTest(id) {
        resetCuts();
        const L = (v) => document.getElementById(v);
        if (id === 1) {
          // 400×2, 100×4 / 1000×3, grip=129, kerf=2.5, tol=+1
          L('stockLength').value = 1000; L('stockCount').value = 3; L('grip').value = 129;
          L('kerf').value = 2.5; L('tolerance').value = 1;
          addCutInput(400,2); addCutInput(100,4);
        } else if (id === 2) {
          // 200×5（+1誤差）/ 1000×1
          L('stockLength').value = 1000; L('stockCount').value = 1; L('grip').value = 100;
          L('kerf').value = 2.5; L('tolerance').value = 1;
          addCutInput(200,5);
        } else if (id === 3) {
          // 600×1, 300×2 / 1000×2
          L('stockLength').value = 1000; L('stockCount').value = 2; L('grip').value = 120;
          L('kerf').value = 3; L('tolerance').value = 0;
          addCutInput(600,1); addCutInput(300,2);
        } else if (id === 4) {
          // あなたのケース：400×10, 100×30, 60×40 / 1000×10
          L('stockLength').value = 1000; L('stockCount').value = 10; L('grip').value = 129;
          L('kerf').value = 2.5; L('tolerance').value = 1;
          addCutInput(400,10); addCutInput(100,30); addCutInput(60,40);
        }
        calculate();
      }

      // 初期：入力行3つ
      for (let i = 0; i < 3; i++) addCutInput();
    }
  </script>
  <script>
    // --- PWA: Service Worker 登録（対応ブラウザのみ） ---
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.error);
      });
    }
  </script>
</body>
</html>
