<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- iPhone入力時の拡大防止 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>帯鋸演算</title>

  <!-- PWA meta -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#2563eb">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="帯鋸演算">
  <link rel="apple-touch-icon" href="icon-180.png">

  <style>
    :root{
      --bg:#111; --bg2:#0c0c0c; --panel:#181818; --panel2:#1f1f1f;
      --text:#fafafa; --muted:#c7c7c7; --border:#2b2b2b;
      --brand:#2f6dff; --brand2:#2455cc; --danger:#ff6b6b;
      --input-bg:#2a2a2a; --input-bg-focus:#343434;
      --y:#ffd54f;
      --radius:12px;
      --label-w:88px;
      --input-w:8ch; /* 00000.0 が入る幅 */
    }
    html,body{background:linear-gradient(180deg,var(--bg),var(--bg2) 60%); color:var(--text);}
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP",sans-serif;
      padding:16px; max-width:900px; margin:auto; -webkit-tap-highlight-color:transparent; -webkit-text-size-adjust:100%;
    }

    h1{margin:0 0 10px; font-size:20px; line-height:1.25; font-weight:700;}
    .unit-note{color:var(--muted); font-size:13px; margin:0 0 12px;}

    .settings{
      background:var(--panel2); border:1px solid var(--border); border-radius:12px; padding:12px;
      display:grid; grid-template-columns: 1fr 1fr; gap:12px 16px;
    }
    .s-row{ display:grid; grid-template-columns: var(--label-w) auto; align-items:center; gap:6px 8px; }
    .s-span-2{ grid-column:1 / -1; display:grid; grid-template-columns: var(--label-w) auto; align-items:center; gap:6px 8px; }
    .s-label{ color:var(--muted); font-size:14px; }
    .s-row > div, .s-span-2 > div{ display:inline-flex; align-items:center; gap:6px; flex-wrap:nowrap; }

    input{
      width:var(--input-w); max-width:100%;
      padding:10px 12px; font-size:16px; line-height:1.2;
      border:1px solid var(--border); border-radius:var(--radius);
      background:var(--input-bg); color:var(--text);
      box-shadow:0 1px 0 rgba(255,255,255,.03) inset, 0 1px 8px rgba(0,0,0,.25);
    }
    input:focus{ outline:none; background:var(--input-bg-focus); border-color:#3e3e3e; }

    h3{margin:16px 0 10px; font-size:16px;}
    .input-sheet{ background:var(--panel2); border:1px solid var(--border); border-radius:12px; padding:10px; }
    .sheet-head{ display:grid; grid-template-columns: 1fr 1fr; gap:8px 16px; padding:2px 2px 8px; color:var(--muted); font-size:13px; }
    #cutInputs{ display:grid; grid-template-columns: 1fr 1fr; gap:10px 16px; }
    .cut-input{ display:contents; }
    .cut-input .length, .cut-input .qty{ width:var(--input-w); }

    .btn{
      background:var(--brand); color:#fff; border:none; border-radius:var(--radius);
      cursor:pointer; padding:12px 16px; font-size:16px; min-height:44px; line-height:1.2;
      box-shadow:0 2px 10px rgba(0,0,0,.35);
    }
    .btn:hover{ background:var(--brand2); }
    .btn-row{ display:grid; grid-template-columns: repeat(2, minmax(160px,1fr)); gap:10px; margin-top:10px; }

    /* 演算ボタン：黄色 */
    .btn-calc{ background:#facc15; color:#111; }
    .btn-calc:hover{ background:#eab308; }

    .tests{margin-top:12px; display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:10px; align-items:stretch;}
    .tests > span{grid-column:1 / -1; color:var(--muted); margin:0 0 -2px;}

    .result{ margin-top:14px; padding:16px; background:var(--panel2); border:1px solid var(--border); border-radius:14px; font-size:15px; line-height:1.65; letter-spacing:.2px; white-space:normal; }
    .y{ color:var(--y); font-weight:600; }
    .danger{ color:#ff6b6b; font-weight:700; }

    .table-wrap{ margin-top:12px; background:var(--panel2); border:1px solid var(--border); border-radius:12px; overflow:auto; }
    .table{ width:100%; min-width:760px; border-collapse:separate; border-spacing:0; font-size:15px; line-height:1.5; }
    .table th, .table td{ padding:10px 12px; border-bottom:1px solid var(--border); white-space:nowrap; }
    .table thead th{ position:sticky; top:0; background:var(--panel2); z-index:1; text-align:left; color:var(--muted); font-weight:600; backdrop-filter:blur(4px); }
    .num{ text-align:right; font-variant-numeric:tabular-nums; }
    .group-head{ font-weight:600; }
    .table tr:last-child td{ border-bottom:none; }
    .subtle{ color:var(--muted); }

    @media (max-width:560px){ .settings{ grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <h1>帯鋸演算</h1>
  <div class="unit-note">（長さ単位：mm）</div>

  <!-- 設定 -->
  <div class="settings">
    <div class="s-row">
      <label class="s-label" for="stockLength">部材長</label>
      <div><input type="number" id="stockLength" value="1000" step="0.1" inputmode="decimal"></div>
    </div>
    <div class="s-row">
      <label class="s-label" for="stockCount">個数</label>
      <div><input type="number" id="stockCount" value="10" step="1" inputmode="numeric"></div>
    </div>
    <div class="s-row">
      <label class="s-label" for="grip">掴みしろ</label>
      <div><input type="number" id="grip" value="129" step="0.1" inputmode="decimal"></div>
    </div>
    <div class="s-row">
      <label class="s-label" for="tolerance">切断誤差</label>
      <div><input type="number" id="tolerance" value="1" step="0.1" inputmode="decimal"></div>
    </div>
    <div class="s-span-2">
      <label class="s-label" for="kerf">1カットの削れ</label>
      <div><input type="number" id="kerf" value="2.5" step="0.1" inputmode="decimal"></div>
    </div>
  </div>

  <!-- 切断長/個数 -->
  <h3>切断長と個数（MAX30）</h3>
  <div class="input-sheet">
    <div class="sheet-head"><div>長さ</div><div>個数</div></div>
    <div id="cutInputs"></div>
  </div>

  <div class="btn-row">
    <button class="btn" onclick="addCutInput()">切断パターン追加</button>
    <button class="btn btn-calc" onclick="calculate()">演算</button>
  </div>

  <div class="tests">
    <span>■ テストケース：</span>
    <button class="btn" onclick="loadTest(1)">T1: 400×2, 100×4 / 1000×3</button>
    <button class="btn" onclick="loadTest(2)">T2: 200×5（+1誤差）/ 1000×1</button>
    <button class="btn" onclick="loadTest(3)">T3: 600×1, 300×2 / 1000×2</button>
    <button class="btn" onclick="loadTest(4)">T4: 400×10, 100×30, 60×40 / 1000×10</button>
  </div>

  <div class="result" id="result"></div>

  <script>
    // 重複定義ガード
    if (!window.__OBIKYO__) window.__OBIKYO__ = {};
    if (!window.__OBIKYO__.initialized) {
      window.__OBIKYO__.initialized = true;
      window.__OBIKYO__.cutRowCount = 0;

      // 行追加（最大30）
      window.addCutInput = function(length = "", qty = ""){
        const maxRows = 30;
        if (window.__OBIKYO__.cutRowCount >= maxRows) return;
        const row = document.createElement('div');
        row.className = 'cut-input';
        row.innerHTML = `
          <input type="number" class="length" placeholder="長さ" aria-label="長さ(mm)" value="${length}" step="0.1" inputmode="decimal">
          <input type="number" class="qty" placeholder="個数" aria-label="個数(本)" value="${qty}" step="1" inputmode="numeric">
        `;
        document.getElementById('cutInputs').appendChild(row);
        window.__OBIKYO__.cutRowCount++;
      };

      // 不足時の通知（システム依存：alert + 可能ならバイブ）
      function alertError(msg){
        try { alert(msg); } catch(e){}
        if (navigator.vibrate) { navigator.vibrate(240); }
      }

      function buildCuts(tolerance){
        const lengths=[...document.querySelectorAll('.length')];
        const qtys=[...document.querySelectorAll('.qty')];
        const cuts=[];
        for(let i=0;i<lengths.length;i++){
          const target=Number(lengths[i].value);
          const qty=Number(qtys[i].value);
          if(!target||!qty) continue;
          const input=target-Number(tolerance); // 誤差+1 → 設定を1短く
          for(let j=0;j<qty;j++) cuts.push({target,input});
        }
        return cuts;
      }

      function statsFromCuts(cuts,kerf){
        const map=new Map(); let totalCuts=0,totalUsage=0;
        for(const c of cuts){ map.set(c.target,(map.get(c.target)||0)+1); totalCuts++; totalUsage+=(c.target+kerf); }
        return {countByTarget:map,totalCuts,totalUsage};
      }

      function assignBoardsDescending(cuts,stockLength,stockCount,grip,kerf){
        const boards=Array.from({length:stockCount},(_,i)=>({id:i+1,cuts:[],used:0}));
        let remaining=cuts.slice().sort((a,b)=>b.target-a.target);
        const CANDIDATE_LIMIT=60, NODE_LIMIT=20000;
        for(const board of boards){
          if(remaining.length===0) break;
          const capacity=stockLength-grip;
          const pool=remaining.slice(0,Math.min(CANDIDATE_LIMIT,remaining.length));
          let bestPlan=[],bestUsed=0,nodes=0;
          function dfs(idx,used,chosen){
            if(++nodes>NODE_LIMIT) return;
            if(used>bestUsed){bestUsed=used;bestPlan=chosen.slice();}
            for(let i=idx;i<pool.length;i++){
              const c=pool[i], need=c.target+kerf;
              if(used+need>capacity) continue;
              chosen.push(c); dfs(i+1,used+need,chosen); chosen.pop();
            }
          }
          dfs(0,0,[]);
          board.cuts=bestPlan;
          board.used=bestPlan.reduce((s,c)=>s+c.target+kerf,0);
          const set=new Set(bestPlan);
          remaining=remaining.filter(x=>!set.has(x));
        }
        return {boards,remaining};
      }

      function gapFill(boards,remaining,stockLength,grip,kerf){
        remaining.sort((a,b)=>a.target-b.target);
        for(const board of boards){
          let cap=(stockLength-grip)-board.used; if(cap<=0) continue;
          for(let i=0;i<remaining.length && cap>0;){
            const c=remaining[i], need=c.target+kerf;
            if(need<=cap+1e-9){ board.cuts.push(c); board.used+=need; cap-=need; remaining.splice(i,1);}
            else break;
          }
          const capMax=stockLength-grip; if(board.used>capMax) board.used=capMax;
        }
        return remaining;
      }

      function tallyCuts(cuts){
        const map=new Map();
        for(const c of cuts){
          const key=`${c.input}->${c.target}`;
          if(!map.has(key)) map.set(key,{input:c.input,target:c.target,count:0});
          map.get(key).count++;
        }
        return Array.from(map.values()).sort((a,b)=>a.target-b.target||a.input-b.input);
      }

      function compressIds(ids){
        ids.sort((a,b)=>a-b); const ranges=[]; let start=ids[0],prev=ids[0];
        for(let i=1;i<ids.length;i++){ const cur=ids[i]; if(cur===prev+1){prev=cur;continue;}
          ranges.push(start===prev?`${start}`:`${start}〜${prev}`); start=prev=cur;}
        ranges.push(start===prev?`${start}`:`${start}〜${prev}`); return ranges.join(',');
      }

      function renderOutput(boards,shortageMap,stockLength,grip,audit){
        const SL=Number(stockLength), GR=Number(grip);

        const sigMap=new Map();
        for(const board of boards){
          if(!board?.cuts?.length) continue;
          const tally=tallyCuts(board.cuts);
          const rEx=Math.max(0,(SL-GR)-board.used);
          const rIn=Math.max(0,SL-board.used);
          const sig=JSON.stringify({tally,rEx:+rEx.toFixed(3),rIn:+rIn.toFixed(3)});
          if(!sigMap.has(sig)) sigMap.set(sig,{ids:[],tally,rEx,rIn});
          sigMap.get(sig).ids.push(board.id);
        }

        let totalRemainInclGrip=0, rowsHtml='';
        for(const {ids,tally,rEx,rIn} of Array.from(sigMap.values()).sort((a,b)=>a.ids[0]-b.ids[0])){
          totalRemainInclGrip += rIn * ids.length;
          const groupLabel=`部材${compressIds(ids)}`;
          const remainCell=`<td class="num" rowspan="${tally.length}">${Number(rIn).toFixed(1)}</td>`+
                           `<td class="num" rowspan="${tally.length}">${Number(rEx).toFixed(1)}</td>`;
          tally.forEach((row,idx)=>{
            const inp=Number(row.input).toFixed(1);
            const tgt=Number(row.target).toFixed(1);
            const qty=row.count;
            const usedLen=(Number(row.target)*qty).toFixed(1);
            const kerfSum=(qty*Number(document.getElementById('kerf').value)).toFixed(1);
            rowsHtml += `<tr>
              ${idx===0?`<td class="group-head" rowspan="${tally.length}">${groupLabel}</td>`:``}
              <td class="num">${tgt}</td>
              <td class="num y">${inp}</td>
              <td class="num y">${qty}</td>
              ${idx===0?remainCell:``}
              <td class="num">${usedLen}</td>
              <td class="num subtle">${kerfSum}</td>
            </tr>`;
          });
        }

        const tableHtml=`
          <div class="table-wrap">
            <table class="table">
              <thead>
                <tr>
                  <th>部材</th>
                  <th class="num">実長</th>
                  <th class="num">機械設定</th>
                  <th class="num">本数</th>
                  <th class="num">余り</th>
                  <th class="num">有効残長</th>
                  <th class="num">実使用長</th>
                  <th class="num">削れ合計</th>
                </tr>
              </thead>
              <tbody>${rowsHtml || `<tr><td colspan="8" class="subtle">切断結果がありません</td></tr>`}</tbody>
            </table>
          </div>`;

        const keys = Array.from(shortageMap.keys()).sort((a,b)=>a-b);
        let below = `<div style="margin-top:8px">合計余り（掴みしろ含む・全材）：<b>${totalRemainInclGrip.toFixed(1)} mm</b></div>`;
        if (keys.length > 0) {
          below += `<div style="margin-top:6px"><b class="danger">切断不足：</b>` +
                   keys.map(k => ` <span class="danger">${Number(k).toFixed(1)}mm × ${shortageMap.get(k)}本</span>`).join(' / ')
                   + `</div>`;
          alertError('切断不足があります。入力や条件をご確認ください。');
        } else {
          below += `<div style="margin-top:6px"><b>切断不足：</b>なし</div>`;
        }
        below += `<div style="margin-top:8px" class="subtle">
          --- 監査 ---　要求 ${audit.demandUsage.toFixed(1)}mm ／ 容量 ${audit.totalCapacity.toFixed(1)}mm ／ 実割当 ${audit.assignedUsage.toFixed(1)}mm ／ 不足発生 ${audit.demandUsage>audit.totalCapacity?'はい':'いいえ'}
        </div>`;

        document.getElementById('result').innerHTML = tableHtml + below;
      }

      window.calculate = function(){
        const stockLength=Number(document.getElementById('stockLength').value);
        const stockCount=Number(document.getElementById('stockCount').value);
        const grip=Number(document.getElementById('grip').value);
        const kerf=Number(document.getElementById('kerf').value);
        const tolerance=Number(document.getElementById('tolerance').value);
        document.getElementById('result').textContent='';

        const cuts=buildCuts(tolerance);
        if(cuts.length===0 || stockCount<=0 || stockLength<=0){
          document.getElementById('result').textContent='入力が不足しています。'; return;
        }
        const demand=statsFromCuts(cuts,kerf);
        const totalCapacity=(stockLength-grip)*stockCount;

        const {boards,remaining}=assignBoardsDescending(cuts,stockLength,stockCount,grip,kerf);
        const afterGap=gapFill(boards,remaining,stockLength,grip,kerf);

        const assignedCutsArray=boards.flatMap(b=>b.cuts);
        const assigned=statsFromCuts(assignedCutsArray,kerf);

        const shortageMap=new Map();
        for(const c of afterGap) shortageMap.set(c.target,(shortageMap.get(c.target)||0)+1);
        if(shortageMap.size===0){
          for(const [t,need] of demand.countByTarget.entries()){
            const done=assigned.countByTarget.get(t)||0;
            if(done<need) shortageMap.set(t,need-done);
          }
        }

        const audit={ demandUsage:demand.totalUsage, totalCapacity, assignedUsage:assigned.totalUsage };
        renderOutput(boards,shortageMap,stockLength,grip,audit);
      };

      window.resetCuts = function(){
        document.getElementById('cutInputs').innerHTML = '';
        window.__OBIKYO__.cutRowCount = 0; // ← タイポ修正（__cutRowCount -> cutRowCount）
      };

      window.loadTest=function(id){
        window.resetCuts?.();
        const L=(v)=>document.getElementById(v);
        if(id===1){ L('stockLength').value=1000; L('stockCount').value=3; L('grip').value=129; L('kerf').value=2.5; L('tolerance').value=1; addCutInput(400,2); addCutInput(100,4); }
        else if(id===2){ L('stockLength').value=1000; L('stockCount').value=1; L('grip').value=100; L('kerf').value=2.5; L('tolerance').value=1; addCutInput(200,5); }
        else if(id===3){ L('stockLength').value=1000; L('stockCount').value=2; L('grip').value=120; L('kerf').value=3; L('tolerance').value=0; addCutInput(600,1); addCutInput(300,2); }
        else if(id===4){ L('stockLength').value=1000; L('stockCount').value=10; L('grip').value=129; L('kerf').value=2.5; L('tolerance').value=1; addCutInput(400,10); addCutInput(100,30); addCutInput(60,40); }
        calculate();
      };

      // 初期行
      for(let i=0;i<3;i++) addCutInput();
    }
  </script>

  <script>
    // PWA: Service Worker
    if('serviceWorker' in navigator){
      window.addEventListener('load',()=>{ navigator.serviceWorker.register('./sw.js').catch(console.error); });
    }
  </script>
</body>
</html>
